This is Info file ../info/emacs, produced by Makeinfo-1.63 from the
input file emacs.texi.


File: emacs,  Node: Regexps,  Next: Search Case,  Prev: Regexp Search,  Up: Search

Syntax of Regular Expressions
=============================

   Regular expressions have a syntax in which a few characters are
special constructs and the rest are "ordinary".  An ordinary character
is a simple regular expression which matches that same character and
nothing else.  The special characters are `$', `^', `.', `*', `+', `?',
`[', `]' and `\'.  Any other character appearing in a regular
expression is ordinary, unless a `\' precedes it.

   For example, `f' is not a special character, so it is ordinary, and
therefore `f' is a regular expression that matches the string `f' and
no other string.  (It does *not* match the string `ff'.)  Likewise, `o'
is a regular expression that matches only `o'.  (When case distinctions
are being ignored, these regexps also match `F' and `O', but we
consider this a generalization of "the same string", rather than an
exception.)

   Any two regular expressions A and B can be concatenated.  The result
is a regular expression which matches a string if A matches some amount
of the beginning of that string and B matches the rest of the string.

   As a simple example, we can concatenate the regular expressions `f'
and `o' to get the regular expression `fo', which matches only the
string `fo'.  Still trivial.  To do something nontrivial, you need to
use one of the special characters.  Here is a list of them.

`. (Period)'
     is a special character that matches any single character except a
     newline.  Using concatenation, we can make regular expressions
     like `a.b' which matches any three-character string which begins
     with `a' and ends with `b'.

`*'
     is not a construct by itself; it is a postfix operator, which
     means to match the preceding regular expression repetitively as
     many times as possible.  Thus, `o*' matches any number of `o's
     (including no `o's).

     `*' always applies to the *smallest* possible preceding
     expression.  Thus, `fo*' has a repeating `o', not a repeating
     `fo'.  It matches `f', `fo', `foo', and so on.

     The matcher processes a `*' construct by matching, immediately, as
     many repetitions as can be found.  Then it continues with the rest
     of the pattern.  If that fails, backtracking occurs, discarding
     some of the matches of the `*'-modified construct in case that
     makes it possible to match the rest of the pattern.  For example,
     matching `ca*ar' against the string `caaar', the `a*' first tries
     to match all three `a's; but the rest of the pattern is `ar' and
     there is only `r' left to match, so this try fails.  The next
     alternative is for `a*' to match only two `a's.  With this choice,
     the rest of the regexp matches successfully.

`+'
     is a postfix character, similar to `*' except that it must match
     the preceding expression at least once.  So, for example, `ca+r'
     matches the strings `car' and `caaaar' but not the string `cr',
     whereas `ca*r' matches all three strings.

`?'
     is a postfix character, similar to `*' except that it can match the
     preceding expression either once or not at all.  For example,
     `ca?r' matches `car' or `cr'; nothing else.

`[ ... ]'
     is a "character set", which begins with `[' and is terminated by
     `]'.  In the simplest case, the characters between the two
     brackets are what this set can match.

     Thus, `[ad]' matches either one `a' or one `d', and `[ad]*'
     matches any string composed of just `a's and `d's (including the
     empty string), from which it follows that `c[ad]*r' matches `cr',
     `car', `cdr', `caddaar', etc.

     You can also include character ranges a character set, by writing
     two characters with a `-' between them.  Thus, `[a-z]' matches any
     lower-case letter.  Ranges may be intermixed freely with individual
     characters, as in `[a-z$%.]', which matches any lower case letter
     or `$', `%' or period.

     Note that the usual regexp special characters are not special
     inside a character set.  A completely different set of special
     characters exists inside character sets: `]', `-' and `^'.

     To include a `]' in a character set, you must make it the first
     character.  For example, `[]a]' matches `]' or `a'.  To include a
     `-', write `-' as the first or last character of the set, or put
     it after a range.  Thus, `[]-]' matches both `]' and `-'.

     To include `^', make it other than the first character in the set.

`[^ ... ]'
     `[^' begins a "complemented character set", which matches any
     character except the ones specified.  Thus, `[^a-z0-9A-Z]' matches
     all characters *except* letters and digits.

     `^' is not special in a character set unless it is the first
     character.  The character following the `^' is treated as if it
     were first (`-' and `]' are not special there).

     A complemented character set can match a newline, unless newline is
     mentioned as one of the characters not to match.  This is in
     contrast to the handling of regexps in programs such as `grep'.

`^'
     is a special character that matches the empty string, but only at
     the beginning of a line in the text being matched.  Otherwise it
     fails to match anything.  Thus, `^foo' matches a `foo' which
     occurs at the beginning of a line.

`$'
     is similar to `^' but matches only at the end of a line.  Thus,
     `xx*$' matches a string of one `x' or more at the end of a line.

`\'
     has two functions: it quotes the special characters (including
     `\'), and it introduces additional special constructs.

     Because `\' quotes special characters, `\$' is a regular
     expression which matches only `$', and `\[' is a regular
     expression which matches only `[', etc.

   Note: for historical compatibility, special characters are treated as
ordinary ones if they are in contexts where their special meanings make
no sense.  For example, `*foo' treats `*' as ordinary since there is no
preceding expression on which the `*' can act.  It is poor practice to
depend on this behavior; better to quote the special character anyway,
regardless of where it appears.

   For the most part, `\' followed by any character matches only that
character.  However, there are several exceptions: two-character
sequences starting with `\' which have special meanings.  The second
character in the sequence is always an ordinary character on their own.
Here is a table of `\' constructs.

`\|'
     specifies an alternative.  Two regular expressions A and B with
     `\|' in between form an expression that matches anything that
     either A or B matches.

     Thus, `foo\|bar' matches either `foo' or `bar' but no other string.

     `\|' applies to the largest possible surrounding expressions.
     Only a surrounding `\( ... \)' grouping can limit the scope of
     `\|'.

     Full backtracking capability exists to handle multiple uses of
     `\|'.

`\( ... \)'
     is a grouping construct that serves three purposes:

       1. To enclose a set of `\|' alternatives for other operations.
          Thus, `\(foo\|bar\)x' matches either `foox' or `barx'.

       2. To enclose a complicated expression for the postfix operators
          `*', `+' and `?' to operate on.  Thus, `ba\(na\)*' matches
          `bananana', etc., with any (zero or more) number of `na'
          strings.

       3. To mark a matched substring for future reference.

     This last application is not a consequence of the idea of a
     parenthetical grouping; it is a separate feature which is assigned
     as a second meaning to the same `\( ... \)' construct.  In practice
     there is no conflict between the two meanings.  Here is an
     explanation of this feature:

`\D'
     after the end of a `\( ... \)' construct, the matcher remembers
     the beginning and end of the text matched by that construct.  Then,
     later on in the regular expression, you can use `\' followed by the
     digit D to mean "match the same text matched the Dth time by the
     `\( ... \)' construct."

     The strings matching the first nine `\( ... \)' constructs
     appearing in a regular expression are assigned numbers 1 through 9
     in order that the open-parentheses appear in the regular
     expression.  `\1' through `\9' refer to the text previously
     matched by the corresponding `\( ... \)' construct.

     For example, `\(.*\)\1' matches any newline-free string that is
     composed of two identical halves.  The `\(.*\)' matches the first
     half, which may be anything, but the `\1' that follows must match
     the same exact text.

     If a particular `\( ... \)' construct matches more than once
     (which can easily happen if it is followed by `*'), only the last
     match is recorded.

`\`'
     matches the empty string, provided it is at the beginning of the
     buffer or string being matched against.

`\''
     matches the empty string, provided it is at the end of the buffer
     or string being matched against.

`\='
     matches the empty string, provided it is at point.

`\b'
     matches the empty string, provided it is at the beginning or end
     of a word.  Thus, `\bfoo\b' matches any occurrence of `foo' as a
     separate word.  `\bballs?\b' matches `ball' or `balls' as a
     separate word.

     `\b' matches at the beginning or end of the buffer regardless of
     what text appears next to it.

`\B'
     matches the empty string, provided it is *not* at the beginning or
     end of a word.

`\<'
     matches the empty string, provided it is at the beginning of a
     word.  `\<' matches at the beginning of the buffer only if a
     word-constituent character follows.

`\>'
     matches the empty string, provided it is at the end of a word.
     `\>' matches at the end of the buffer only if the contents end with
     a word-constituent character.

`\w'
     matches any word-constituent character.  The syntax table
     determines which characters these are.  *Note Syntax::.

`\W'
     matches any character that is not a word-constituent.

`\sC'
     matches any character whose syntax is C.  Here C is a character
     which represents a syntax code: thus, `w' for word constituent,
     `(' for open-parenthesis, etc.  Represent a character of
     whitespace (which can be a newline) by either `-' or a space
     character.

`\SC'
     matches any character whose syntax is not C.

   The constructs that pertain to words and syntax are controlled by the
setting of the syntax table (*note Syntax::.).

   Here is a complicated regexp, used by Emacs to recognize the end of a
sentence together with any whitespace that follows.  It is given in Lisp
syntax to enable you to distinguish the spaces from the tab characters.
In Lisp syntax, the string constant begins and ends with a
double-quote.  `\"' stands for a double-quote as part of the regexp,
`\\' for a backslash as part of the regexp, `\t' for a tab and `\n' for
a newline.

     "[.?!][]\"')]*\\($\\|\t\\|  \\)[ \t\n]*"

This contains four parts in succession: a character set matching period,
`?', or `!'; a character set matching close-brackets, quotes, or
parentheses, repeated any number of times; an alternative in
backslash-parentheses that matches end-of-line, a tab, or two spaces;
and a character set matching whitespace characters, repeated any number
of times.

   To enter the same regexp interactively, you would type TAB to enter
a tab, and `C-q C-j' to enter a newline.  You would also type single
backslashes as themselves, instead of doubling them for Lisp syntax.


File: emacs,  Node: Search Case,  Next: Replace,  Prev: Regexps,  Up: Search

Searching and Case
==================

   Incremental searches in Emacs normally ignore the case of the text
they are searching through, if you specify the text in lower case.
Thus, if you specify searching for `foo', then `Foo' and `foo' are also
considered a match.  Regexps, and in particular character sets, are
included: `[ab]' would match `a' or `A' or `b' or `B'.

   An upper-case letter in the incremental search string makes the
search case-sensitive.  Thus, searching for `Foo' does not find `foo'
or `FOO'.  This applies to regular expression search as well as to
string search.  The effect ceases if you delete the upper-case letter
from the search string.

   If you set the variable `case-fold-search' to `nil', then all
letters must match exactly, including case.  This is a per-buffer
variable; altering the variable affects only the current buffer, but
there is a default value which you can change as well.  *Note Locals::.
This variable applies to nonincremental searches also, including those
performed by the replace commands (*note Replace::.).


File: emacs,  Node: Replace,  Next: Other Repeating Search,  Prev: Search Case,  Up: Search

Replacement Commands
====================

   Global search-and-replace operations are not needed as often in Emacs
as they are in other editors(1), but they are available.  In addition
to the simple `M-x replace-string' command which is like that found in
most editors, there is a `M-x query-replace' command which asks you, for
each occurrence of the pattern, whether to replace it.

   The replace commands all replace one string (or regexp) with one
replacement string.  It is possible to perform several replacements in
parallel using the command `expand-region-abbrevs'.  *Note Expanding
Abbrevs::.

* Menu:

* Unconditional Replace::  Replacing all matches for a string.
* Regexp Replace::         Replacing all matches for a regexp.
* Replacement and Case::   How replacements preserve case of letters.
* Query Replace::          How to use querying.

   ---------- Footnotes ----------

   (1)  In some editors, search-and-replace operations are the only
convenient way to make a single change in the text.


File: emacs,  Node: Unconditional Replace,  Next: Regexp Replace,  Prev: Replace,  Up: Replace

Unconditional Replacement
-------------------------

`M-x replace-string RET STRING RET NEWSTRING RET'
     Replace every occurrence of STRING with NEWSTRING.

`M-x replace-regexp RET REGEXP RET NEWSTRING RET'
     Replace every match for REGEXP with NEWSTRING.

   To replace every instance of `foo' after point with `bar', use the
command `M-x replace-string' with the two arguments `foo' and `bar'.
Replacement happens only in the text after point, so if you want to
cover the whole buffer you must go to the beginning first.  All
occurrences up to the end of the buffer are replaced; to limit
replacement to part of the buffer, narrow to that part of the buffer
before doing the replacement (*note Narrowing::.).

   When `replace-string' exits, it leaves point at the last occurrence
replaced.  It sets the mark to the prior position of point (where the
`replace-string' command was issued); use `C-u C-SPC' to move back
there.

   A numeric argument restricts replacement to matches that are
surrounded by word boundaries.  The argument's value doesn't matter.


File: emacs,  Node: Regexp Replace,  Next: Replacement and Case,  Prev: Unconditional Replace,  Up: Replace

Regexp Replacement
------------------

   The `M-x replace-string' command replaces exact matches for a single
string.  The similar command `M-x replace-regexp' replaces any match
for a specified pattern.

   In `replace-regexp', the NEWSTRING need not be constant: it can
refer to all or part of what is matched by the REGEXP.  `\&' in
NEWSTRING stands for the entire match being replaced.  `\D' in
NEWSTRING, where D is a digit, stands for whatever matched the Dth
parenthesized grouping in REGEXP.  To include a `\' in the text to
replace with, you must enter `\\'.  For example,

     M-x replace-regexp RET c[ad]+r RET \&-safe RET

replaces (for example) `cadr' with `cadr-safe' and `cddr' with
`cddr-safe'.

     M-x replace-regexp RET \(c[ad]+r\)-safe RET \1 RET

performs the inverse transformation.


File: emacs,  Node: Replacement and Case,  Next: Query Replace,  Prev: Regexp Replace,  Up: Replace

Replace Commands and Case
-------------------------

   If the arguments to a replace command are in lower case, it preserves
case when it makes a replacement.  Thus, the command

     M-x replace-string RET foo RET bar RET

replaces a lower case `foo' with a lower case `bar', an all-caps `FOO'
with `BAR', and a capitalized `Foo' with `Bar'.  (These three
alternatives-lower case, all caps, and capitalized, are the only ones
that `replace-string' can distinguish.)

   If upper case letters are used in the second argument, they remain
upper case every time that argument is inserted.  If upper case letters
are used in the first argument, the second argument is always
substituted exactly as given, with no case conversion.  Likewise, if the
variable `case-replace' is set to `nil', replacement is done without
case conversion.  If `case-fold-search' is set to `nil', case is
significant in matching occurrences of `foo' to replace; this also
inhibits case conversion of the replacement string.


File: emacs,  Node: Query Replace,  Prev: Replacement and Case,  Up: Replace

Query Replace
-------------

`M-% STRING RET NEWSTRING RET'
`M-x query-replace RET STRING RET NEWSTRING RET'
     Replace some occurrences of STRING with NEWSTRING.

`M-x query-replace-regexp RET REGEXP RET NEWSTRING RET'
     Replace some matches for REGEXP with NEWSTRING.

   If you want to change only some of the occurrences of `foo' to
`bar', not all of them, then you cannot use an ordinary
`replace-string'.  Instead, use `M-%' (`query-replace').  This command
finds occurrences of `foo' one by one, displays each occurrence and
asks you whether to replace it.  A numeric argument to `query-replace'
tells it to consider only occurrences that are bounded by
word-delimiter characters.  This preserves case, just like
`replace-string', provided `case-replace' is non-`nil', as it normally
is.

   Aside from querying, `query-replace' works just like
`replace-string', and `query-replace-regexp' works just like
`replace-regexp'.  The shortest way to type this command name is `M-x
que SPC SPC SPC RET'.

   The things you can type when you are shown an occurrence of STRING
or a match for REGEXP are:

`SPC'
     to replace the occurrence with NEWSTRING.

`DEL'
     to skip to the next occurrence without replacing this one.

`, (Comma)'
     to replace this occurrence and display the result.  You are then
     asked for another input character to say what to do next.  Since
     the replacement has already been made, DEL and SPC are equivalent
     in this situation; both move to the next occurrence.

     You could type `C-r' at this point (see below) to alter the
     replaced text.  You could also type `C-x u' to undo the
     replacement; this exits the `query-replace', so if you want to do
     further replacement you must use `C-x ESC ESC RET' to restart
     (*note Repetition::.).

`RET'
     to exit without doing any more replacements.

`. (Period)'
     to replace this occurrence and then exit without searching for more
     occurrences.

`!'
     to replace all remaining occurrences without asking again.

`^'
     to go back to the position of the previous occurrence (or what
     used to be an occurrence), in case you changed it by mistake.
     This works by popping the mark ring.  Only one `^' in a row is
     meaningful, because only one previous replacement position is kept
     during `query-replace'.

`C-r'
     to enter a recursive editing level, in case the occurrence needs
     to be edited rather than just replaced with NEWSTRING.  When you
     are done, exit the recursive editing level with `C-M-c' to proceed
     to the next occurrence.  *Note Recursive Edit::.

`C-w'
     to delete the occurrence, and then enter a recursive editing level
     as in `C-r'.  Use the recursive edit to insert text to replace the
     deleted occurrence of STRING.  When done, exit the recursive
     editing level with `C-M-c' to proceed to the next occurrence.

`C-l'
     to redisplay the screen.  Then you must type another character to
     specify what to do with this occurrence.

`C-h'
     to display a message summarizing these options.  Then you must type
     another character to specify what to do with this occurrence.

   Some other characters are aliases for the ones listed above: `y',
`n' and `q' are equivalent to SPC, DEL and RET.

   Aside from this, any other character exits the `query-replace', and
is then reread as part of a key sequence.  Thus, if you type `C-k', it
exits the `query-replace' and then kills to end of line.

   To restart a `query-replace' once it is exited, use `C-x ESC ESC',
which repeats the `query-replace' because it used the minibuffer to
read its arguments.  *Note C-x ESC ESC: Repetition.

   See also *Note Transforming File Names::, for Dired commands to
rename, copy, or link files by replacing regexp matches in file names.


File: emacs,  Node: Other Repeating Search,  Prev: Replace,  Up: Search

Other Search-and-Loop Commands
==============================

   Here are some other commands that find matches for a regular
expression.  They all operate from point to the end of the buffer.

`M-x occur RET REGEXP RET'
     Display a list showing each line in the buffer that contains a
     match for REGEXP.  A numeric argument specifies the number of
     context lines to print before and after each matching line; the
     default is none.  To limit the search to part of the buffer,
     narrow to that part (*note Narrowing::.).

     The buffer `*Occur*' containing the output serves as a menu for
     finding the occurrences in their original context.  Click `Mouse-2'
     on an occurrence listed in `*Occur*', or position point there and
     type RET; this switches to the buffer that was searched and moves
     point to the original of the chosen occurrence.

`M-x list-matching-lines'
     Synonym for `M-x occur'.

`M-x count-matches RET REGEXP RET'
     Print the number of matches for REGEXP after point.

`M-x flush-lines RET REGEXP RET'
     Delete each line that follows point and contains a match for
     REGEXP.

`M-x keep-lines RET REGEXP RET'
     Delete each line that follows point and *does not* contain a match
     for REGEXP.


File: emacs,  Node: Fixit,  Next: Files,  Prev: Search,  Up: Top

Commands for Fixing Typos
*************************

   In this chapter we describe the commands that are especially useful
for the times when you catch a mistake in your text just after you have
made it, or change your mind while composing text on the fly.

   The most fundamental command for correcting erroneous editing is the
undo command, `C-x u' or `C-_'.  This command undoes a single command
(usually), a part of a command (in the case of `query-replace'), or
several consecutive self-inserting characters.  Consecutive repetitions
of `C-_' or `C-x u' undo earlier and earlier changes, back to the limit
of the undo information available.  *Note Undo::, for for more
information.

* Menu:

* Kill Errors:: Commands to kill a batch of recently entered text.
* Transpose::   Exchanging two characters, words, lines, lists...
* Fixing Case:: Correcting case of last word entered.
* Spelling::    Apply spelling checker to a word, or a whole file.


File: emacs,  Node: Kill Errors,  Next: Transpose,  Up: Fixit

Killing Your Mistakes
=====================

`DEL'
     Delete last character (`delete-backward-char').

`M-DEL'
     Kill last word (`backward-kill-word').

`C-x DEL'
     Kill to beginning of sentence (`backward-kill-sentence').

   The DEL character (`delete-backward-char') is the most important
correction command.  It deletes the character before point.  When DEL
follows a self-inserting character command, you can think of it as
canceling that command.  However, avoid the mistake of thinking of DEL
as a general way to cancel a command!

   When your mistake is longer than a couple of characters, it might be
more convenient to use `M-DEL' or `C-x DEL'.  `M-DEL' kills back to the
start of the last word, and `C-x DEL' kills back to the start of the
last sentence.  `C-x DEL' is particularly useful when you change your
mind about the phrasing of the text you are writing.  `M-DEL' and `C-x
DEL' save the killed text for `C-y' and `M-y' to retrieve.  *Note
Yanking::.

   `M-DEL' is often useful even when you have typed only a few
characters wrong, if you know you are confused in your typing and aren't
sure exactly what you typed.  At such a time, you cannot correct with
DEL except by looking at the screen to see what you did.  Often it
requires less thought to kill the whole word and start again.


File: emacs,  Node: Transpose,  Next: Fixing Case,  Prev: Kill Errors,  Up: Fixit

Transposing Text
================

`C-t'
     Transpose two characters (`transpose-chars').

`M-t'
     Transpose two words (`transpose-words').

`C-M-t'
     Transpose two balanced expressions (`transpose-sexps').

`C-x C-t'
     Transpose two lines (`transpose-lines').

   The common error of transposing two characters can be fixed, when
they are adjacent, with the `C-t' command (`transpose-chars').
Normally, `C-t' transposes the two characters on either side of point.
When given at the end of a line, rather than transposing the last
character of the line with the newline, which would be useless, `C-t'
transposes the last two characters on the line.  So, if you catch your
transposition error right away, you can fix it with just a `C-t'.  If
you don't catch it so fast, you must move the cursor back to between
the two transposed characters.  If you transposed a space with the last
character of the word before it, the word motion commands are a good
way of getting there.  Otherwise, a reverse search (`C-r') is often the
best way.  *Note Search::.

   `M-t' (`transpose-words') transposes the word before point with the
word after point.  It moves point forward over a word, dragging the
word preceding or containing point forward as well.  The punctuation
characters between the words do not move.  For example, `FOO, BAR'
transposes into `BAR, FOO' rather than `BAR FOO,'.

   `C-M-t' (`transpose-sexps') is a similar command for transposing two
expressions (*note Lists::.), and `C-x C-t' (`transpose-lines')
exchanges lines.  They work like `M-t' except in determining the
division of the text into syntactic units.

   A numeric argument to a transpose command serves as a repeat count:
it tells the transpose command to move the character (word, sexp, line)
before or containing point across several other characters (words,
sexps, lines).  For example, `C-u 3 C-t' moves the character before
point forward across three other characters.  It would change
`f-!-oobar' into `oobf-!-ar'.  This is equivalent to repeating `C-t'
three times.  `C-u - 4 M-t' moves the word before point backward across
four words.  `C-u - C-M-t' would cancel the effect of plain `C-M-t'.

   A numeric argument of zero is assigned a special meaning (because
otherwise a command with a repeat count of zero would do nothing): to
transpose the character (word, sexp, line) ending after point with the
one ending after the mark.


File: emacs,  Node: Fixing Case,  Next: Spelling,  Prev: Transpose,  Up: Fixit

Case Conversion
===============

`M-- M-l'
     Convert last word to lower case.  Note `Meta--' is Meta-minus.

`M-- M-u'
     Convert last word to all upper case.

`M-- M-c'
     Convert last word to lower case with capital initial.

   A very common error is to type words in the wrong case.  Because of
this, the word case-conversion commands `M-l', `M-u' and `M-c' have a
special feature when used with a negative argument: they do not move the
cursor.  As soon as you see you have mistyped the last word, you can
simply case-convert it and go on typing.  *Note Case::.


File: emacs,  Node: Spelling,  Prev: Fixing Case,  Up: Fixit

Checking and Correcting Spelling
================================

   This section describes the commands to check the spelling of a single
word or of a portion of a buffer.  These commands work with the spelling
checker program Ispell, which is not part of Emacs.  *Note Ispell: (The
Ispell Manual)Top.

`M-$'
     Check and correct spelling of word at point (`ispell-word').

`M-TAB'
     Complete the word before point based on the spelling dictionary
     (`ispell-complete-word').

`M-x ispell-buffer'
     Check and correct spelling of each word in the buffer.

`M-x ispell-region'
     Check and correct spelling of each word in the region.

`M-x ispell-message'
     Check and correct spelling of each word in a draft mail message,
     excluding cited material.

`M-x ispell-change-dictionary RET DICT RET'
     Restart the ispell process, using DICT as the dictionary.

`M-x ispell-kill-ispell'
     Kill the Ispell subprocess.

   To check the spelling of the word around or next to point, and
optionally correct it as well, use the command `M-$' (`ispell-word').
If the word is not correct, the command offers you various alternatives
for what to do about it.

   To check the entire current buffer, use `M-x ispell-buffer'.  Use
`M-x ispell-region' to check just the current region.  To check
spelling in an email message you are writing, use `M-x ispell-message';
that checks the whole buffer, but does not check material that is
indented or appears to be cited from other messages.

   Each time these commands encounter an incorrect word, they ask you
what to do.  It displays a list of alternatives, usually including
several "near-misses"--words that are close to the word being checked.
Then you must type a character.  Here are the valid responses:

`SPC'
     Skip this word--continue to consider it incorrect, but don't
     change it here.

`r NEW RET'
     Replace the word (just this time) with NEW.

`R NEW RET'
     Replace the word with NEW, and do a `query-replace' so you can
     replace it elsewhere in the buffer if you wish.

`DIGIT'
     Replace the word (just this time) with one of the displayed
     near-misses.  Each near-miss is listed with a digit; type that
     digit to select it.

`a'
     Accept the incorrect word--treat it as correct, but only in this
     editing session.

`A'
     Accept the incorrect word--treat it as correct, but only in this
     editing session and for this buffer.

`i'
     Insert this word in your private dictionary file so that Ispell
     will consider it correct it from now on, even in future sessions.

`u'
     Insert a lower-case version of this word in your private dictionary
     file.

`m'
     Like `i', but you can also specify dictionary completion
     information.

`l WORD RET'
     Look in the dictionary for words that match WORD.  These words
     become the new list of "near-misses"; you can select one of them to
     replace with by typing a digit.  You can use `*' in WORD as a
     wildcard.

`C-g'
     Quit interactive spell checking.  You can restart it again
     afterward with `C-u M-$'.

`X'
     Same as `C-g'.

`x'
     Quit interactive spell checking and move point back to where it was
     when you started spell checking.

`q'
     Quit interactive spell checking and kill the Ispell subprocess.

`C-l'
     Refresh the screen.

`C-z'
     This key has its normal command meaning (suspend Emacs or iconify
     this frame).

   The command `ispell-complete-word', which is bound to the key
`M-TAB' in Text mode and related modes, shows a list of completions
based on spelling correction.  Insert the beginning of a word, and then
type `M-TAB'; the command displays a completion list window.  To choose
one of the completions listed, click `Mouse-2' on it, or move the
cursor there in the completions window and type RET.  *Note Text Mode::.

   Once started, the Ispell subprocess continues to run (waiting for
something to do), so that subsequent spell checking commands complete
more quickly.  If you want to get rid of the Ispell process, use `M-x
ispell-kill-ispell'.  This is not usually necessary, since the process
uses no time except when you do spelling correction.

   Ispell uses two dictionaries: the standard dictionary and your
private dictionary.  The variable `ispell-dictionary' specifies the file
name of the standard dictionary to use.  A value of `nil' says to use
the default dictionary.  The command `M-x ispell-change-dictionary'
sets this variable and then restarts the Ispell subprocess, so that it
will use a different dictionary.


File: emacs,  Node: Files,  Next: Buffers,  Prev: Fixit,  Up: Top

File Handling
*************

   The operating system stores data permanently in named "files".  So
most of the text you edit with Emacs comes from a file and is ultimately
stored in a file.

   To edit a file, you must tell Emacs to read the file and prepare a
buffer containing a copy of the file's text.  This is called "visiting"
the file.  Editing commands apply directly to text in the buffer; that
is, to the copy inside Emacs.  Your changes appear in the file itself
only when you "save" the buffer back into the file.

   In addition to visiting and saving files, Emacs can delete, copy,
rename, and append to files, keep multiple versions of them, and operate
on file directories.

* Menu:

* File Names::       How to type and edit file name arguments.
* Visiting::         Visiting a file prepares Emacs to edit the file.
* Saving::           Saving makes your changes permanent.
* Reverting::        Reverting cancels all the changes not saved.
* Auto Save::        Auto Save periodically protects against loss of data.
* File Aliases::     Handling multiple names for one file.
* Version Control::  Version control systems (RCS, CVS and SCCS).
* Directories::      Creating, deleting and listing file directories.
* Comparing Files::  Finding where two files differ.
* Misc File Ops::    Other things you can do on files.
* Compressed Files:: Accessing compressed files.


File: emacs,  Node: File Names,  Next: Visiting,  Up: Files

File Names
==========

   Most Emacs commands that operate on a file require you to specify the
file name.  (Saving and reverting are exceptions; the buffer knows which
file name to use for them.)  You enter the file name using the
minibuffer (*note Minibuffer::.).  "Completion" is available, to make
it easier to specify long file names.  *Note Completion::.

   For most operations, there is a "default file name" which is used if
you type just RET to enter an empty argument.  Normally the default
file name is the name of the file visited in the current buffer; this
makes it easy to operate on that file with any of the Emacs file
commands.

   Each buffer has a default directory, normally the same as the
directory of the file visited in that buffer.  When you enter a file
name without a directory, the default directory is used.  If you specify
a directory in a relative fashion, with a name that does not start with
a slash, it is interpreted with respect to the default directory.  The
default directory is kept in the variable `default-directory', which
has a separate value in every buffer.

   For example, if the default file name is `/u/rms/gnu/gnu.tasks' then
the default directory is `/u/rms/gnu/'.  If you type just `foo', which
does not specify a directory, it is short for `/u/rms/gnu/foo'.
`../.login' would stand for `/u/rms/.login'.  `new/foo' would stand for
the file name `/u/rms/gnu/new/foo'.

   The command `M-x pwd' prints the current buffer's default directory,
and the command `M-x cd' sets it (to a value read using the
minibuffer).  A buffer's default directory changes only when the `cd'
command is used.  A file-visiting buffer's default directory is
initialized to the directory of the file that is visited there.  If you
create a buffer with `C-x b', its default directory is copied from that
of the buffer that was current at the time.

   The default directory actually appears in the minibuffer when the
minibuffer becomes active to read a file name.  This serves two
purposes: it *shows* you what the default is, so that you can type a
relative file name and know with certainty what it will mean, and it
allows you to *edit* the default to specify a different directory.
This insertion of the default directory is inhibited if the variable
`insert-default-directory' is set to `nil'.

   Note that it is legitimate to type an absolute file name after you
enter the minibuffer, ignoring the presence of the default directory
name as part of the text.  The final minibuffer contents may look
invalid, but that is not so.  For example, if the minibuffer starts out
with `/usr/tmp/' and you add `/x1/rms/foo', you get
`/usr/tmp//x1/rms/foo'; but Emacs ignores everything through the first
slash in the double slash; the result is `/x1/rms/foo'.  *Note
Minibuffer File::.

   You can refer to files on other machines using a special file name
syntax:

     /HOST:FILENAME
     /USER@HOST:FILENAME

When you do this, Emacs uses the FTP program to read and write files on
the specified host.  It logs in through FTP using your user name or the
name USER.  It may ask you for a password from time to time; this is
used for logging in on HOST.

   You can turn off the FTP file name feature by setting the variable
`file-name-handler-alist' to `nil'.

   `$' in a file name is used to substitute environment variables.  For
example, if you have used the shell command `export FOO=rms/hacks' to
set up an environment variable named `FOO', then you can use
`/u/$FOO/test.c' or `/u/${FOO}/test.c' as an abbreviation for
`/u/rms/hacks/test.c'.  The environment variable name consists of all
the alphanumeric characters after the `$'; alternatively, it may be
enclosed in braces after the `$'.  Note that shell commands to set
environment variables affect Emacs only if done before Emacs is started.

   To access a file with `$' in its name, type `$$'.  This pair is
converted to a single `$' at the same time as variable substitution is
performed for single `$'.  The Lisp function that performs the
substitution is called `substitute-in-file-name'.  The substitution is
performed only on file names read as such using the minibuffer.


File: emacs,  Node: Visiting,  Next: Saving,  Prev: File Names,  Up: Files

Visiting Files
==============

`C-x C-f'
     Visit a file (`find-file').

`C-x C-r'
     Visit a file for viewing, without allowing changes to it
     (`find-file-read-only').

`C-x C-v'
     Visit a different file instead of the one visited last
     (`find-alternate-file').

`C-x 4 C-f'
     Visit a file, in another window (`find-file-other-window').  Don't
     change the selected window.

`C-x 5 C-f'
     Visit a file, in a new frame (`find-file-other-frame').  Don't
     change the selected frame.

`M-x auto-compression-mode'
     Toggle automatic uncompression and recompression for compressed
     files.

   "Visiting" a file means copying its contents into an Emacs buffer so
you can edit them.  Emacs makes a new buffer for each file that you
visit.  We say that this buffer is visiting the file that it was created
to hold.  Emacs constructs the buffer name from the file name by
throwing away the directory, keeping just the name proper.  For example,
a file named `/usr/rms/emacs.tex' would get a buffer named `emacs.tex'.
If there is already a buffer with that name, a unique name is
constructed by appending `<2>', `<3>', or so on, using the lowest
number that makes a name that is not already in use.

   Each window's mode line shows the name of the buffer that is being
displayed in that window, so you can always tell what buffer you are
editing.

   The changes you make with editing commands are made in the Emacs
buffer.  They do not take effect in the file that you visited, or any
place permanent, until you "save" the buffer.  Saving the buffer means
that Emacs writes the current contents of the buffer into its visited
file.  *Note Saving::.

   If a buffer contains changes that have not been saved, we say the
buffer is "modified".  This is important because it implies that some
changes will be lost if the buffer is not saved.  The mode line
displays two stars near the left margin to indicate that the buffer is
modified.

   To visit a file, use the command `C-x C-f' (`find-file').  Follow
the command with the name of the file you wish to visit, terminated by a
RET.

   The file name is read using the minibuffer (*note Minibuffer::.),
with defaulting and completion in the standard manner (*note File
Names::.).  While in the minibuffer, you can abort `C-x C-f' by typing
`C-g'.

   Your confirmation that `C-x C-f' has completed successfully is the
appearance of new text on the screen and a new buffer name in the mode
line.  If the specified file does not exist and could not be created, or
cannot be read, then you get an error, with an error message displayed
in the echo area.

   If you visit a file that is already in Emacs, `C-x C-f' does not make
another copy.  It selects the existing buffer containing that file.
However, before doing so, it checks that the file itself has not changed
since you visited or saved it last.  If the file has changed, a warning
message is printed.  *Note Simultaneous Editing: Interlocking.

   What if you want to create a new file?  Just visit it.  Emacs prints
`(New File)' in the echo area, but in other respects behaves as if you
had visited an existing empty file.  If you make any changes and save
them, the file is created.

   If the file you specify is actually a directory, `C-x C-f' invokes
Dired, the Emacs directory browser so that you can "edit" the contents
of the directory (*note Dired::.).  Dired is a convenient way to delete,
look at, or operate on the files in the directory.  However, if the
variable `find-file-run-dired' is `nil', then it is an error to try to
visit a directory.

   If you visit a file that the operating system won't let you modify,
Emacs makes the buffer read-only, so that you won't go ahead and make
changes that you'll have trouble saving afterward.  You can make the
buffer writable with `C-x C-q' (`vc-toggle-read-only').  *Note Misc
Buffer::.

   Occasionally you might want to visit a file as read-only in order to
protect yourself from entering changes accidentally; do so by visiting
the file with the command `C-x C-r' (`find-file-read-only').

   If you visit a nonexistent file unintentionally (because you typed
the wrong file name), use the `C-x C-v' command (`find-alternate-file')
to visit the file you really wanted.  `C-x C-v' is similar to `C-x
C-f', but it kills the current buffer (after first offering to save it
if it is modified).  When it reads the file name to visit, it inserts
the entire default file name in the buffer, with point just after the
directory part; this is convenient if you made a slight error in typing
the name.

   `C-x 4 f' (`find-file-other-window') is like `C-x C-f' except that
the buffer containing the specified file is selected in another window.
The window that was selected before `C-x 4 f' continues to show the
same buffer it was already showing.  If this command is used when only
one window is being displayed, that window is split in two, with one
window showing the same buffer as before, and the other one showing the
newly requested file.  *Note Windows::.

   `C-x 5 f' (`find-file-other-frame') is similar, but opens a new
frame, or makes visible any existing frame showing the file you seek.
This feature is available only when you are using a window system.
*Note Frames::.

   Two special hook variables allow extensions to modify the operation
of visiting files.  Visiting a file that does not exist runs the
functions in the list `find-file-not-found-hooks'; this variable holds
a list of functions, and the functions are called one by one until one
of them returns non-`nil'.  Any visiting of a file, whether extant or
not, expects `find-file-hooks' to contain a list of functions and calls
them all, one by one.  In both cases the functions receive no
arguments.  Of these two variables, `find-file-not-found-hooks' takes
effect first.  These variables are *not* normal hooks, and their names
end in `-hooks' rather than `-hook' to indicate that fact.  *Note
Hooks::.

   The command `M-x auto-compression-mode' toggles a mode in which
visiting a compressed file automatically uncompresses it.  (Editing the
file and saving it automatically recompresses it.)

   There are several ways to specify automatically the major mode for
editing the file (*note Choosing Modes::.), and to specify local
variables defined for that file (*note File Variables::.).


File: emacs,  Node: Saving,  Next: Reverting,  Prev: Visiting,  Up: Files

Saving Files
============

   "Saving" a buffer in Emacs means writing its contents back into the
file that was visited in the buffer.

`C-x C-s'
     Save the current buffer in its visited file (`save-buffer').

`C-x s'
     Save any or all buffers in their visited files
     (`save-some-buffers').

`M-~'
     Forget that the current buffer has been changed (`not-modified').

`C-x C-w'
     Save the current buffer in a specified file (`write-file').

`M-x set-visited-file-name'
     Change file the name under which the current buffer will be saved.

   When you wish to save the file and make your changes permanent, type
`C-x C-s' (`save-buffer').  After saving is finished, `C-x C-s'
displays a message like this:

     Wrote /u/rms/gnu/gnu.tasks

If the selected buffer is not modified (no changes have been made in it
since the buffer was created or last saved), saving is not really done,
because it would have no effect.  Instead, `C-x C-s' displays a message
like this in the echo area:

     (No changes need to be saved)

   The command `C-x s' (`save-some-buffers') offers to save any or all
modified buffers.  It asks you what to do with each buffer.  The
possible responses are analogous to those of `query-replace':

`y'
     Save this buffer and ask about the rest of the buffers.

`n'
     Don't save this buffer, but ask about the rest of the buffers.

`!'
     Save this buffer and all the rest with no more questions.

`RET'
     Terminate `save-some-buffers' without any more saving.

`.'
     Save this buffer, then exit `save-some-buffers' without even asking
     about other buffers.

`C-r'
     View the buffer that you are currently being asked about.  When
     you exit View mode, you get back to `save-some-buffers', which
     asks the question again.

`C-h'
     Display a help message about these options.

   `C-x C-c', the key sequence to exit Emacs, invokes
`save-some-buffers' and therefore asks the same questions.

   If you have changed a buffer but you do not want to save the changes,
you should take some action to prevent it.  Otherwise, each time you use
`C-x s' or `C-x C-c', you are liable to save this buffer by mistake.
One thing you can do is type `M-~' (`not-modified'), which clears out
the indication that the buffer is modified.  If you do this, none of
the save commands will believe that the buffer needs to be saved.  (`~'
is often used as a mathematical symbol for `not'; thus `M-~' is `not',
metafied.)  You could also use `set-visited-file-name' (see below) to
mark the buffer as visiting a different file name, one which is not in
use for anything important.  Alternatively, you can cancel all the
changes made since the file was visited or saved, by reading the text
from the file again.  This is called "reverting".  *Note Reverting::.
You could also undo all the changes by repeating the undo command `C-x
u' until you have undone all the changes; but reverting is easier.

   `M-x set-visited-file-name' alters the name of the file that the
current buffer is visiting.  It reads the new file name using the
minibuffer.  Then it specifies the visited file name and changes the
buffer name correspondingly (as long as the new name is not in use).
`set-visited-file-name' does not save the buffer in the newly visited
file; it just alters the records inside Emacs in case you do save
later.  It also marks the buffer as "modified" so that `C-x C-s' in
that buffer *will* save.

   If you wish to mark the buffer as visiting a different file and save
it right away, use `C-x C-w' (`write-file').  It is precisely
equivalent to `set-visited-file-name' followed by `C-x C-s'.  `C-x C-s'
used on a buffer that is not visiting with a file has the same effect
as `C-x C-w'; that is, it reads a file name, marks the buffer as
visiting that file, and saves it there.  The default file name in a
buffer that is not visiting a file is made by combining the buffer name
with the buffer's default directory.

   If Emacs is about to save a file and sees that the date of the latest
version on disk does not match what Emacs last read or wrote, Emacs
notifies you of this fact, because it probably indicates a problem
caused by simultaneous editing and requires your immediate attention.
*Note Simultaneous Editing: Interlocking.

   If the variable `require-final-newline' is non-`nil', Emacs puts a
newline at the end of any file that doesn't already end in one, every
time a file is saved or written.

* Menu:

* Backup::        How Emacs saves the old version of your file.
* Interlocking::  How Emacs protects against simultaneous editing
                    of one file by two users.

